(()=>{"use strict";var t={d:(e,r)=>{for(var o in r)t.o(r,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:r[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{HexMemoryMap:()=>n,S19MemoryMap:()=>a});const r=/:([0-9A-Fa-f]{8,})([0-9A-Fa-f]{2})(?:\r\n|\r|\n|)/g;function o(t){return 255&-t.reduce(((t,e)=>t+e),0)}function s(t){return t.toString(16).toUpperCase().padStart(2,"0")}Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t};class n{_blocks;constructor(t){if(this._blocks=new Map,t&&Symbol.iterator in t)for(const e of t){if(!Array.isArray(e)||2!==e.length)throw new Error("First parameter to HexMemoryMap constructor must be an iterable of [addr, bytes] or undefined");this.set(e[0],e[1])}else if("object"==typeof t){if(t){const e=Object.keys(t);for(const r of e)this.set(parseInt(r),t[r])}}else if(null!=t)throw new Error("First parameter to HexMemoryMap constructor must be an iterable of [addr, bytes] or undefined")}set(t,e){if(!Number.isInteger(t))throw new Error("Address passed to HexMemoryMap is not an integer");if(t<0)throw new Error("Address passed to HexMemoryMap is negative");if(!(e instanceof Buffer))throw new Error("Bytes passed to HexMemoryMap are not an Buffer");return this._blocks.set(t,e)}get(t){return this._blocks.get(t)}clear(){return this._blocks.clear()}delete(t){return this._blocks.delete(t)}entries(){return this._blocks.entries()}forEach(t,e){return this._blocks.forEach(t,e)}has(t){return this._blocks.has(t)}keys(){return this._blocks.keys()}values(){return this._blocks.values()}get size(){return this._blocks.size}[Symbol.iterator](){return this._blocks[Symbol.iterator]()}static fromHex(t,e=1/0){const a=new n;let i,f=0,l=0,c=0;for(r.lastIndex=0;null!==(i=r.exec(t));){if(l++,f!==i.index)throw new Error("Malformed hex file: Could not parse between characters "+f+" and "+i.index+' ("'+t.substring(f,Math.min(i.index,f+16)).trim()+'")');f=r.lastIndex;const[,n,h]=i,u=Buffer.from(n.match(/[\da-f]{2}/gi)?.map((t=>parseInt(t,16)))||[]),g=u[0];if(g+4!==u.length)throw new Error("Mismatched record length at record "+l+" ("+i[0].trim()+"), expected "+g+" data bytes but actual length is "+(u.length-4));const d=o(u);if(parseInt(h,16)!==d)throw new Error("Checksum failed at record "+l+" ("+i[0].trim()+"), should be "+d.toString(16));const p=(u[1]<<8)+u[2],b=u[3],w=u.subarray(4);if(0===b){if(a.has(c+p))throw new Error("Duplicated data at record "+l+" ("+i[0].trim()+")");if(p+w.length>65536)throw new Error("Data at record "+l+" ("+i[0].trim()+") wraps over 0xFFFF. This would trigger ambiguous behaviour. Please restructure your data so that for every record the data offset plus the data length do not exceed 0xFFFF.");a.set(c+p,w)}else{if(0!==p)throw new Error("Record "+l+" ("+i[0].trim()+") must have 0000 as data offset.");switch(b){case 1:if(f!==t.length)throw new Error("There is data after an EOF record at record "+l);return a.join(e);case 2:c=(w[0]<<8)+w[1]<<4;break;case 3:case 5:break;case 4:c=(w[0]<<8)+w[1]<<16;break;default:throw new Error("Invalid record type 0x"+s(b)+" at record "+l+" (should be between 0x00 and 0x05)")}}}throw l?new Error("No EOF record at end of file"):new Error("Malformed .hex file, could not parse any registers")}join(t=1/0){const e=Array.from(this.keys()).sort(((t,e)=>t-e)),r=new Map;let o=-1,s=-1;for(let n=0,a=e.length;n<a;n++){const a=e[n],i=this.get(e[n]).length;if(s===a&&s-o<t)r.set(o,r.get(o)+i),s+=i;else{if(!(s<=a))throw new Error("Overlapping data around address 0x"+a.toString(16));r.set(a,i),o=a,s=a+i}}const a=new n;let i,f=-1;for(let t=0,o=e.length;t<o;t++){const o=e[t];r.has(o)&&(i=Buffer.alloc(r.get(o)),a.set(o,i),f=o),i.set(this.get(o),o-f)}return a}static overlapHexMemoryMaps(t){const e=new Set;for(const[,r]of t)for(const[t,o]of r)e.add(t),e.add(t+o.length);const r=Array.from(e.values()).sort(((t,e)=>t-e)),o=new Map;for(let e=0,s=r.length-1;e<s;e++){const s=r[e],n=r[e+1],a=[];for(const[e,r]of t){const t=Array.from(r.keys()).reduce(((t,e)=>e>s?t:Math.max(t,e)),-1);if(-1!==t){const o=r.get(t),i=s-t,f=n-t;i<o.length&&a.push([e,o.subarray(i,f)])}}a.length&&o.set(s,a)}return o}static flattenOverlaps(t){return new n(Array.from(t.entries()).map((([t,e])=>[t,e[e.length-1][1]])))}paginate(t=1024,e=255){if(t<=0)throw new Error("Page size must be greater than zero");const r=new n;let o;const s=Array.from(this.keys()).sort(((t,e)=>t-e));for(let n=0,a=s.length;n<a;n++){const a=s[n],i=this.get(a),f=i.length,l=a+f;for(let s=a-a%t;s<l;s+=t){o=r.get(s),o||(o=Buffer.alloc(t),o.fill(e),r.set(s,o));const n=s-a;let l;n<=0?(l=i.subarray(0,Math.min(t+n,f)),o.set(l,-n)):(l=i.subarray(n,n+Math.min(t,f-n)),o.set(l,0))}}return r}getUint32(t,e){const r=Array.from(this.keys());for(let o=0,s=r.length;o<s;o++){const s=r[o],n=this.get(s),a=n.length;if(s<=t&&t+4<=s+a)return new DataView(n.buffer,t-s,4).getUint32(0,e)}}asHexString(t=16){let e=0,r=-65536;const n=[];if(t<=0)throw new Error("Size of record must be greater than zero");if(t>255)throw new Error("Size of record must be less than 256");const a=Buffer.alloc(6),i=Buffer.alloc(4),f=Array.from(this.keys()).sort(((t,e)=>t-e));for(let c=0,h=f.length;c<h;c++){const h=f[c],u=this.get(h);if(!(u instanceof Buffer))throw new Error("Block at offset "+h+" is not an Buffer");if(h<0)throw new Error("Block at offset "+h+" has a negative thus invalid address");const g=u.length;if(!g)continue;if(h>r+65535&&(r=h-h%65536,e=0,a[0]=2,a[1]=0,a[2]=0,a[3]=4,a[4]=r>>24,a[5]=r>>16,n.push(":"+Array.prototype.map.call(a,s).join("")+s(o(a)))),h<r+e)throw new Error("Block starting at 0x"+h.toString(16)+" overlaps with a previous block.");e=h%65536;let d=0;const p=h+g;if(p>4294967295)throw new Error("Data cannot be over 0xFFFFFFFF");for(;r+e<p;){e>65535&&(r+=65536,e=0,a[0]=2,a[1]=0,a[2]=0,a[3]=4,a[4]=r>>24,a[5]=r>>16,n.push(":"+Array.prototype.map.call(a,s).join("")+s(o(a))));let f=-1;for(;e<65536&&f;)if(f=Math.min(t,p-r-e,65536-e),f){i[0]=f,i[1]=e>>8,i[2]=e,i[3]=0;const t=u.subarray(d,d+f);n.push(":"+Array.prototype.map.call(i,s).join("")+Array.prototype.map.call(t,s).join("")+s((l=t,255&-(i.reduce(((t,e)=>t+e),0)+l.reduce(((t,e)=>t+e),0))))),d+=f,e+=f}}}var l;return n.push(":00000001FF"),n.join("\n")}clone(){const t=new n;for(const[e,r]of this)t.set(e,Buffer.from(r));return t}static fromPaddedBuffer(t,e=255,r=64){if(!(t instanceof Buffer))throw new Error("Bytes passed to fromPaddedBuffer are not an Buffer");const o=new n;let s=0,a=-1,i=0,f=!1;const l=t.length;for(let n=0;n<l;n++)t[n]===e?(s++,s>=r&&(-1!==a&&o.set(i,t.subarray(i,a+1)),f=!0)):(f&&(f=!1,i=n),a=n,s=0);return f||-1===a||o.set(i,t.subarray(i,l)),o}slice(t,e=1/0){if(e<0)throw new Error("Length of the slice cannot be negative");const r=new n;for(const[o,s]of this){const n=s.length;if(o+n>=t&&o<t+e){const a=Math.max(t,o),i=Math.min(t+e,o+n)-a,f=a-o;i>0&&r.set(a,s.subarray(f,f+i))}}return r}slicePad(t,e,r=255){if(e<0)throw new Error("Length of the slice cannot be negative");const o=Buffer.alloc(e,r);for(const[r,s]of this){const n=s.length;if(r+n>=t&&r<t+e){const a=Math.max(t,r),i=Math.min(t+e,r+n)-a,f=a-r;i>0&&o.set(s.subarray(f,f+i),a-t)}}return o}contains(t){for(const[e,r]of t){const t=r.length,o=this.slice(e,t).join().get(e);if(!o||o.length!==t)return!1;for(const t in r)if(r[t]!==o[t])return!1}return!0}}class a{_blocks;constructor(t){if(this._blocks=new Map,t&&Symbol.iterator in t)for(const e of t){if(!Array.isArray(e)||2!==e.length)throw new Error("First parameter to S19MemoryMap constructor must be an iterable of [addr, bytes] or undefined");this.set(e[0],e[1])}else if("object"==typeof t){if(t){const e=Object.keys(t);for(const r of e)this.set(parseInt(r),t[r])}}else if(null!=t)throw new Error("First parameter to S19MemoryMap constructor must be an iterable of [addr, bytes] or undefined")}set(t,e){if(!Number.isInteger(t))throw new Error("Address passed to S19MemoryMap is not an integer");if(t<0)throw new Error("Address passed to S19MemoryMap is negative");if(!(e instanceof Buffer))throw new Error("Bytes passed to S19MemoryMap are not an Buffer");return this._blocks.set(t,e)}get(t){return this._blocks.get(t)}clear(){return this._blocks.clear()}delete(t){return this._blocks.delete(t)}entries(){return this._blocks.entries()}forEach(t,e){return this._blocks.forEach(t,e)}has(t){return this._blocks.has(t)}keys(){return this._blocks.keys()}values(){return this._blocks.values()}get size(){return this._blocks.size}[Symbol.iterator](){return this._blocks[Symbol.iterator]()}static fromS19(t,e=1/0){const r=new a,o=t.split(/\r?\n/);let s=0,n=0;for(const t of o){const e=t.trim();if(!e)continue;if(s++,!e.startsWith("S"))throw new Error(`Line ${s} does not start with 'S': "${e}"`);if(e.length<4)throw new Error(`Line ${s} is too short: "${e}"`);const o=parseInt(e[1]),a=e.substr(2,2),i=parseInt(a,16);if(isNaN(i))throw new Error(`Invalid length field in line ${s}: "${a}"`);const f=4+2*i;if(e.length!==f)throw new Error(`Line ${s} has incorrect length. Expected ${f}, got ${e.length}: "${e}"`);const l=e.substr(4);let c=i;for(let t=0;t<l.length-2;t+=2)c+=parseInt(l.substr(t,2),16);c=255&~c;const h=parseInt(l.substr(l.length-2),16);if(c!==h)throw new Error(`Checksum mismatch in line ${s}. Expected ${c.toString(16).toUpperCase().padStart(2,"0")}, got ${h.toString(16).toUpperCase().padStart(2,"0")}`);switch(o){case 0:case 5:case 6:break;case 1:{const t=l.substr(0,4),e=parseInt(t,16),o=l.substr(4,l.length-6);if(o.length%2!=0)throw new Error(`Invalid data bytes length in line ${s}: "${o}"`);const n=Buffer.from(o.match(/.{2}/g)?.map((t=>parseInt(t,16)))||[]);n.length>0&&r.set(e,n)}break;case 2:{const t=l.substr(0,6),e=parseInt(t,16),o=l.substr(6,l.length-8);if(o.length%2!=0)throw new Error(`Invalid data bytes length in line ${s}: "${o}"`);const n=Buffer.from(o.match(/.{2}/g)?.map((t=>parseInt(t,16)))||[]);n.length>0&&r.set(e,n)}break;case 3:{const t=l.substr(0,8),e=parseInt(t,16),o=l.substr(8,l.length-10);if(o.length%2!=0)throw new Error(`Invalid data bytes length in line ${s}: "${o}"`);const n=Buffer.from(o.match(/.{2}/g)?.map((t=>parseInt(t,16)))||[]);n.length>0&&r.set(e,n)}break;case 7:{const t=l.substr(0,8);n=parseInt(t,16)}break;case 8:{const t=l.substr(0,6);n=parseInt(t,16)}break;case 9:{const t=l.substr(0,4);n=parseInt(t,16)}break;default:throw new Error(`Unsupported record type S${o} in line ${s}`)}}return r.join(e)}join(t=1/0){const e=Array.from(this.keys()).sort(((t,e)=>t-e)),r=new Map;let o=-1,s=-1;for(let n=0,a=e.length;n<a;n++){const a=e[n],i=this.get(e[n]).length;if(s===a&&s-o<t)r.set(o,r.get(o)+i),s+=i;else{if(!(s<=a))throw new Error("Overlapping data around address 0x"+a.toString(16));r.set(a,i),o=a,s=a+i}}const n=new a;let i,f=-1;for(let t=0,o=e.length;t<o;t++){const o=e[t];r.has(o)&&(i=Buffer.alloc(r.get(o)),n.set(o,i),f=o),i.set(this.get(o),o-f)}return n}static overlapS19MemoryMaps(t){const e=new Set;for(const[,r]of t)for(const[t,o]of r)e.add(t),e.add(t+o.length);const r=Array.from(e.values()).sort(((t,e)=>t-e)),o=new Map;for(let e=0,s=r.length-1;e<s;e++){const s=r[e],n=r[e+1],a=[];for(const[e,r]of t){const t=Array.from(r.keys()).reduce(((t,e)=>e>s?t:Math.max(t,e)),-1);if(-1!==t){const o=r.get(t),i=s-t,f=n-t;i<o.length&&a.push([e,o.subarray(i,f)])}}a.length&&o.set(s,a)}return o}static flattenOverlaps(t){return new a(Array.from(t.entries()).map((([t,e])=>[t,e[e.length-1][1]])))}paginate(t=1024,e=255){if(t<=0)throw new Error("Page size must be greater than zero");const r=new a;let o;const s=Array.from(this.keys()).sort(((t,e)=>t-e));for(let n=0,a=s.length;n<a;n++){const a=s[n],i=this.get(a),f=i.length,l=a+f;for(let s=a-a%t;s<l;s+=t){o=r.get(s),o||(o=Buffer.alloc(t),o.fill(e),r.set(s,o));const n=s-a;let l;n<=0?(l=i.subarray(0,Math.min(t+n,f)),o.set(l,-n)):(l=i.subarray(n,n+Math.min(t,f-n)),o.set(l,0))}}return r}getUint32(t,e){const r=Array.from(this.keys());for(let o=0,s=r.length;o<s;o++){const s=r[o],n=this.get(s),a=n.length;if(s<=t&&t+4<=s+a)return new DataView(n.buffer,t-s,4).getUint32(0,e)}}asS19String(t=16){if(t<=0)throw new Error("Size of record must be greater than zero");if(t>255)throw new Error("Size of record must be less than 256");const e=[],r=Buffer.from("ECB S19 export");let o="S0";o+=(2+r.length+1).toString(16).toUpperCase().padStart(2,"0"),o+="0000",o+=Array.from(r).map((t=>t.toString(16).toUpperCase().padStart(2,"0"))).join("");let s=2+r.length+1+0+0;for(const t of r)s+=t;s=255&~s,o+=s.toString(16).toUpperCase().padStart(2,"0"),e.push(o);let n=0;const a=Array.from(this.keys()).sort(((t,e)=>t-e)),i=a.length>0?Math.max(...a.map((t=>t+(this.get(t)?.length||0)))):0;let f="S1",l=2;i>16777215?(f="S3",l=4):i>65535&&(f="S2",l=3);for(const r of a){const o=this.get(r);if(!o||0===o.length)continue;let s=r;for(let r=0;r<o.length;r+=t){const a=Math.min(t,o.length-r),i=o.subarray(r,r+a);let c=f;const h=l+1+a;c+=h.toString(16).toUpperCase().padStart(2,"0"),c+=s.toString(16).toUpperCase().padStart(2*l,"0"),c+=Array.from(i).map((t=>t.toString(16).toUpperCase().padStart(2,"0"))).join("");let u=h;"S3"===f?(u+=s>>24&255,u+=s>>16&255):"S2"===f&&(u+=s>>16&255),u+=s>>8&255,u+=255&s;for(const t of i)u+=t;u=255&~u,c+=u.toString(16).toUpperCase().padStart(2,"0"),e.push(c),s+=a,n++}}if(n<=65535){let t="S5";t+="03",t+=n.toString(16).toUpperCase().padStart(4,"0");let r=3+(n>>8&255)+(255&n);r=255&~r,t+=r.toString(16).toUpperCase().padStart(2,"0"),e.push(t)}let c="S3"===f?"S7":"S2"===f?"S8":"S9";const h=l,u=h+1;c+=u.toString(16).toUpperCase().padStart(2,"0"),c+="0000".padStart(2*h,"0");let g=u;for(let t=0;t<h;t++)g+=0;return g=255&~g,c+=g.toString(16).toUpperCase().padStart(2,"0"),e.push(c),e.join("\n")}clone(){const t=new a;for(const[e,r]of this)t.set(e,Buffer.from(r));return t}static fromPaddedBuffer(t,e=255,r=64){if(!(t instanceof Buffer))throw new Error("Bytes passed to fromPaddedBuffer are not an Buffer");const o=new a;let s=0,n=-1,i=0,f=!1;const l=t.length;for(let a=0;a<l;a++)t[a]===e?(s++,s>=r&&(-1!==n&&o.set(i,t.subarray(i,n+1)),f=!0)):(f&&(f=!1,i=a),n=a,s=0);return f||-1===n||o.set(i,t.subarray(i,l)),o}slice(t,e=1/0){if(e<0)throw new Error("Length of the slice cannot be negative");const r=new a;for(const[o,s]of this){const n=s.length;if(o+n>=t&&o<t+e){const a=Math.max(t,o),i=Math.min(t+e,o+n)-a,f=a-o;i>0&&r.set(a,s.subarray(f,f+i))}}return r}slicePad(t,e,r=255){if(e<0)throw new Error("Length of the slice cannot be negative");const o=Buffer.alloc(e,r);for(const[r,s]of this){const n=s.length;if(r+n>=t&&r<t+e){const a=Math.max(t,r),i=Math.min(t+e,r+n)-a,f=a-r;i>0&&o.set(s.subarray(f,f+i),a-t)}}return o}contains(t){for(const[e,r]of t){const t=r.length,o=this.slice(e,t).join().get(e);if(!o||o.length!==t)return!1;for(const t in r)if(r[t]!==o[t])return!1}return!0}}var i=exports;for(var f in e)i[f]=e[f];e.__esModule&&Object.defineProperty(i,"__esModule",{value:!0})})();
//# sourceMappingURL=utli.js.map